{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FuturePool","text":""},{"location":"#futurepool.futurepool.FuturePool","title":"FuturePool","text":"<pre><code>FuturePool(number_of_workers: int = cpu_count() or 1)\n</code></pre> <p>Class representing a pool of async workers to simplify working with async functions that need to be restrained. Common use is fetching data from sites, where in order to not influence the website performance, limit on active connections is set.</p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def __init__(self, number_of_workers: int = (os.cpu_count() or 1)):\n    \"\"\" \"\"\"\n    assert number_of_workers &gt; 0, \"Number of workers must be a positive number\"\n    self.number_of_workers = number_of_workers\n    self.loop = get_running_loop()\n    self.workers_locks = [asyncio.Lock() for _ in range(self.number_of_workers)]\n    self.tasks = set[Task]()\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.imap","title":"imap","text":"<pre><code>imap(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; Iterator[Awaitable[U]]\n</code></pre> <p>Lazy equivalent of <code>map()</code>. Returns iterator of futures.</p> <p>Examples: <pre><code>async with FuturePool(3) as fp:\n    iterator = fp.imap(async_fn, range(10000))\n    a = await next(iterator)\n    b = await next(iterator)\n    c = await next(iterator)\n\nasync with FuturePool(3) as fp:\n    for future in fp.imap(async_fn, range(10000)):\n        result = await future\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def imap(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; Iterator[Awaitable[U]]:\n    \"\"\"\n    Lazy equivalent of `map()`. Returns iterator of futures.\n\n    Examples:\n    ``` python\n    async with FuturePool(3) as fp:\n        iterator = fp.imap(async_fn, range(10000))\n        a = await next(iterator)\n        b = await next(iterator)\n        c = await next(iterator)\n\n    async with FuturePool(3) as fp:\n        for future in fp.imap(async_fn, range(10000)):\n            result = await future\n            do_sth(result)\n    ```\n    \"\"\"\n\n    return self._get_iterator_(fn, ((arg,) for arg in iterable), True)\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.imap_async","title":"imap_async","text":"<pre><code>imap_async(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; AsyncIterator[U]\n</code></pre> <p>Lazy async equivalent of <code>map()</code>. Returns async iterator of U.</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    async for result in fp.imap_async(async_fn, range(10000)):\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def imap_async(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; AsyncIterator[U]:\n    \"\"\"\n    Lazy async equivalent of `map()`. Returns async iterator of U.\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        async for result in fp.imap_async(async_fn, range(10000)):\n            do_sth(result)\n    ```\n    \"\"\"\n\n    return FuturePool.IteratorToAsyncIterator(self.imap(fn, iterable))\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.imap_unordered","title":"imap_unordered","text":"<pre><code>imap_unordered(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; Iterator[Awaitable[U]]\n</code></pre> <p>The same as <code>imap()</code> except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be 'correct'.)</p> <p>Examples: <pre><code>async with FuturePool(3) as fp:\n    iterator = fp.imap_unordered(async_fn_that_takes_variable_time, range(10000))\n    a = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n    b = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n    c = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n\nasync with FuturePool(3) as fp:\n    for future in fp.imap_unordered(async_fn_that_takes_variable_time, range(10000)):\n        result = await future // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def imap_unordered(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; Iterator[Awaitable[U]]:\n    \"\"\"\n    The same as `imap()` except that the ordering of the results from the returned iterator should be considered arbitrary.\n    (Only when there is only one worker process is the order guaranteed to be 'correct'.)\n\n    Examples:\n    ``` python\n    async with FuturePool(3) as fp:\n        iterator = fp.imap_unordered(async_fn_that_takes_variable_time, range(10000))\n        a = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n        b = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n        c = await next(iterator) // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n\n    async with FuturePool(3) as fp:\n        for future in fp.imap_unordered(async_fn_that_takes_variable_time, range(10000)):\n            result = await future // could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n            do_sth(result)\n    ```\n    \"\"\"\n    return self._get_iterator_(fn, ((arg,) for arg in iterable), False)\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.imap_unordered_async","title":"imap_unordered_async","text":"<pre><code>imap_unordered_async(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; AsyncIterator[U]\n</code></pre> <p>The same as <code>imap_async()</code> except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be 'correct'.)</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    async for result in fp.imap_unordered_async(async_fn_that_takes_variable_time, range(10000)):\n        // result could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def imap_unordered_async(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; AsyncIterator[U]:\n    \"\"\"\n    The same as `imap_async()` except that the ordering of the results from the returned iterator should be considered arbitrary.\n    (Only when there is only one worker process is the order guaranteed to be 'correct'.)\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        async for result in fp.imap_unordered_async(async_fn_that_takes_variable_time, range(10000)):\n            // result could be async_fn_that_takes_variable_time(0) or async_fn_that_takes_variable_time(1) or ...\n            do_sth(result)\n    ```\n    \"\"\"\n    return FuturePool.IteratorToAsyncIterator(self.imap_unordered(fn, iterable))\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.map","title":"map","text":"<pre><code>map(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; Awaitable[list[U]]\n</code></pre> <p>Parallel equivalent of standard map function. Applies provided fn on each item in iterable utilizing number_of_workers workers. Function returns Future of all results.</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    result = await fp.map(async_fn, range(3))\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def map(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; Awaitable[list[U]]:\n    \"\"\"Parallel equivalent of standard map function. Applies provided fn on each item in iterable\n    utilizing number_of_workers workers. Function returns Future of all results.\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        result = await fp.map(async_fn, range(3))\n    ```\n\n    \"\"\"\n    return self.starmap(fn, ((arg,) for arg in iterable))\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.starimap","title":"starimap","text":"<pre><code>starimap(fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]) -&gt; Iterator[Awaitable[U]]\n</code></pre> <p>Like <code>imap()</code> except that the elements of the iterable are expected to be iterables that are unpacked as arguments.</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    iterator = fp.starimap(async_fn_with_2_args, zip(range(10000), range(10000)))\n    a = await next(iterator)\n    b = await next(iterator)\n    c = await next(iterator)\n\nasync with FuturePool(3) as fp:\n    for future in fp.starimap(async_fn_with_2_args, zip(range(10000), range(10000))):\n        result = await future\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def starimap(\n    self, fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]\n) -&gt; Iterator[Awaitable[U]]:\n    \"\"\"\n    Like `imap()` except that the elements of the iterable are expected to be iterables that are unpacked as arguments.\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        iterator = fp.starimap(async_fn_with_2_args, zip(range(10000), range(10000)))\n        a = await next(iterator)\n        b = await next(iterator)\n        c = await next(iterator)\n\n    async with FuturePool(3) as fp:\n        for future in fp.starimap(async_fn_with_2_args, zip(range(10000), range(10000))):\n            result = await future\n            do_sth(result)\n    ```\n    \"\"\"\n\n    return self._get_iterator_(fn, iterable, True)\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.starimap_async","title":"starimap_async","text":"<pre><code>starimap_async(fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]) -&gt; AsyncIterator[U]\n</code></pre> <p>Lazy async equivalent of <code>starimap()</code>. Returns async iterator of U.</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    async for result in fp.starimap_async(async_fn_with_2_args, zip(range(10000), range(10000))):\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def starimap_async(\n    self, fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]\n) -&gt; AsyncIterator[U]:\n    \"\"\"\n    Lazy async equivalent of `starimap()`. Returns async iterator of U.\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        async for result in fp.starimap_async(async_fn_with_2_args, zip(range(10000), range(10000))):\n            do_sth(result)\n    ```\n    \"\"\"\n\n    return FuturePool.IteratorToAsyncIterator(self.starimap(fn, iterable))\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.starimap_unordered","title":"starimap_unordered","text":"<pre><code>starimap_unordered(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; Iterator[Awaitable[U]]\n</code></pre> <p>The same as <code>starimap()</code> except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be 'correct'.)</p> <p>Examples: <pre><code>async with FuturePool(3) as fp:\n    iterator = fp.starimap_unordered(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000)))\n    a = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n    b = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n    c = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n\nasync with FuturePool(3) as fp:\n    for future in fp.starimap_unordered(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000))):\n        result = await future // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def starimap_unordered(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; Iterator[Awaitable[U]]:\n    \"\"\"\n    The same as `starimap()` except that the ordering of the results from the returned iterator should be considered arbitrary.\n    (Only when there is only one worker process is the order guaranteed to be 'correct'.)\n\n    Examples:\n    ``` python\n    async with FuturePool(3) as fp:\n        iterator = fp.starimap_unordered(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000)))\n        a = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n        b = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n        c = await next(iterator) // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n\n    async with FuturePool(3) as fp:\n        for future in fp.starimap_unordered(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000))):\n            result = await future // could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n            do_sth(result)\n    ```\n    \"\"\"\n    return self._get_iterator_(fn, iterable, False)\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.starimap_unordered_async","title":"starimap_unordered_async","text":"<pre><code>starimap_unordered_async(fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]) -&gt; AsyncIterator[U]\n</code></pre> <p>The same as <code>starimap_async()</code> except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be 'correct'.)</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    async for result in fp.starimap_unordered_async(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000))):\n        // result could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n        do_sth(result)\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def starimap_unordered_async(\n    self, fn: Callable[[T], Awaitable[U]], iterable: Iterable[T]\n) -&gt; AsyncIterator[U]:\n    \"\"\"\n    The same as `starimap_async()` except that the ordering of the results from the returned iterator should be considered arbitrary.\n    (Only when there is only one worker process is the order guaranteed to be 'correct'.)\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        async for result in fp.starimap_unordered_async(async_fn_that_takes_variable_time_with_2_args, zip(range(10000), range(10000))):\n            // result could be async_fn_that_takes_variable_time_with_2_args(0, 0) or async_fn_that_takes_variable_time_with_2_args(1, 1) or ...\n            do_sth(result)\n    ```\n    \"\"\"\n    return FuturePool.IteratorToAsyncIterator(self.starimap_unordered(fn, iterable))\n</code></pre>"},{"location":"#futurepool.futurepool.FuturePool.starmap","title":"starmap","text":"<pre><code>starmap(fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]) -&gt; Awaitable[list[U]]\n</code></pre> <p>Like <code>map()</code> except that the elements of the iterable are expected to be iterables that are unpacked as arguments. Hence an iterable of <code>[(1,2), (3, 4)]</code> results in <code>[func(1,2), func(3,4)]</code>.</p> <p>Example: <pre><code>async with FuturePool(3) as fp:\n    result = await fp.starmap(async_fn_with_2_args, zip(range(3), range(3)))\n</code></pre></p> Source code in <code>futurepool/futurepool.py</code> <pre><code>def starmap(\n    self, fn: Callable[[Any], Awaitable[U]], iterable: Iterable[Iterable[Any]]\n) -&gt; Awaitable[list[U]]:\n    \"\"\"\n    Like `map()` except that the elements of the iterable are expected to be iterables that are unpacked as arguments.\n    Hence an iterable of `[(1,2), (3, 4)]` results in `[func(1,2), func(3,4)]`.\n\n    Example:\n    ``` python\n    async with FuturePool(3) as fp:\n        result = await fp.starmap(async_fn_with_2_args, zip(range(3), range(3)))\n    ```\n    \"\"\"\n\n    async def lazy_resolve():\n        return [await future for future in self._get_iterator_(fn, iterable, True)]\n\n    return lazy_resolve()\n</code></pre>"}]}